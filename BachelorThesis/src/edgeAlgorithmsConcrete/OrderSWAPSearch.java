package edgeAlgorithmsConcrete;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import edgeAlgorithms.OrderBasedAlgorithms;


/**
 * A local search algorithm for edge coloring. It generates a starting
 * solution based on the order the edges of a graph were given and the 
 * chromatic index calculated by the greedy algorithm. A neighboring 
 * solution is generated by swapping the places of two edges in the 
 * order of edges. These two edges are determined by random. 
 * 100 iterations without improvements are done before
 * the algorithm stops. It also ends if the lower bound of the chromatic 
 * index is reached.
 * 
 * @author Stephanie Heyderich
 */
public class OrderSWAPSearch extends OrderBasedAlgorithms {
	
	@Override
	protected List<Point> createNewOrder(List<Point> old) {
		List<List<Point>> neighbors = getNeighbors(old);
		List<Point> best = getBest(neighbors);
		return best;
	}

	/**
	 * Creates all neighbouring orders
	 * @param old
	 * @return
	 */
	private List<List<Point>> getNeighbors(List<Point> old) {
		List<List<Point>> neighbors = new ArrayList<List<Point>>(); 
		for(int i = 0; i < old.size()-1; i++){
			for(int j = i+1; j < old.size(); j++){
				List<Point> neighbor = new ArrayList<Point>(old);
				Collections.swap(neighbor, i, j);
				neighbors.add(neighbor);
			}
		}
		return neighbors;
	}
	
	/**
	 * Evaluates the given orders and returns the best
	 * @param neighbors
	 * @return
	 */
	private List<Point> getBest(List<List<Point>> neighbors) {
		List<Point> best = neighbors.get(0);
		int nrColors = getNumberColors(best);
		int tmp; 
		for(List<Point> n : neighbors){
			if((tmp = getNumberColors(n)) < nrColors){
				nrColors = tmp; 
				best = n; 
			}
		}
		return best;
	}
	
	private int getNumberColors(List<Point> order){
		Greedy g = new Greedy(order);
		g.applyAlgorithmComplete(graph);
		return graph.getQuantityColors();
	}
	
}
